#ifndef BULLET_MODEL_S3D
#define BULLET_MODEL_S3D

/**
 * internal defaults
 */
#define BULLET_DEFAULT_SPEED 0.2 /**< speed */

/**
 * BulletModel class represent a bullet
 * 
 * This class provide all methods to manage a bullet
 * 
 */
class BulletModel {
	var Pid; /**< int, id of the player owning this */
	
	var position; 	/**< vector, space position  */
	var direction;	/**< vector, going direction */
	var speed;		/**< float, moving speed  */
	var damage;		/**< int, damage points, subtracted to a 
					 *	player hp when it collides with him */
					 
	var radiusOfInfluence; /**< float, radius of the bullet */
	
	
	/**
	 * BulletModel Ctor
	 * 
	 * @param[in]	pid		int, player id
	 * @param[in]	position	float vector, space position
	 * @param[in]	direction	float vector, going direction
	 * @param[in]	speed		float, modulus of the speed
	 * @param[in]	damage		float, damage point
	 * @param[in]	radiusOfInfluence	float, radius of the bullet
	 * @return	BulletModel
	 * 		
	 */
	BulletModel(pid, position, direction, speed, damage, radiusOfInfluence);
	
	/**
	 * Update state (position, direction and speed are constants for now)
	 */
	Update();
	
	/**
	 * Check if is colliding with a point
	 * 
	 * @return	true if it is colliding, false otherwise
	 */
	IsCollidingWithPoint(point);
	
	/**
	 * Check if is colliding with a sphere
	 * 
	 * @return	true if it is colliding, false otherwise
	 */
	IsCollidingWithSphere(center, radius);
	
	/**
	 * Marshall and Unmarshall functions to comunicate with server 
	 */
	Marshall();
	MarshallDelta(model);
	Unmarshall(model);
};

//
function BulletModel::BulletModel(pid, position, direction, speed, damage, radiusOfInfluence) {
	
	this.pid = pid;
	
	this.position = position;
	
	this.direction = direction;
	
	if (speed == void){
		speed = BULLET_DEFAULT_SPEED; 
	}
	this.speed = speed;
	
	this.damage = damage;
	
	this.radiusOfInfluence = radiusOfInfluence;
}

//
function BulletModel::Update() {
	position += direction*speed;
}

//
function BulletModel::IsCollidingWithPoint(point) {
	var delta = point - this.position;
	var mod = modulus(delta);
	
	if (mod <= radiusOfInfluence) {
		return true;
	}
	return false;
}

//
function BulletModel::IsCollidingWithSphere(center, radius) {
	var delta = center - this.position;
	var mod = modulus(delta);
	
	if (mod <= radiusOfInfluence + radius) {
		return true;
	}
	return false; 
}

//
function BulletModel::Marshall() {
	return {
		{ "Pid", Pid},
		{ "position", position},
		{ "direction", direction},
		{ "speed", speed},
		{ "damage", damage},
		{ "rof", radiusOfInfluence}
	};
}

//
function BulletModel::MarshallDelta(model) {
	var myModel = this.Marshall();
	
	if (len(model) == 0) {
		return myModel;
	}
	
	var deltaModel = Array(0);
	for (var i=0,j=0; i<len(myModel); i++){
		var myModelKey = myModel[i][0], myModelVal = myModel[i][1];
		
		if (myModelkey=="shootedBullets" || j >= len(model)) {
			aadd(deltaModel, myModel[i]);
			continue;
		}
		
		var modelKey = model[j][0], modelVal = model[j][1];
		
		if(myModelKey == modelKey) {
			if (myModelVal != modelVal) {
				aadd(deltaModel, myModel[i]);
			}
			j++;
		} else {
			aadd(deltaModel, myModel[i]);	
		}
		
	}
	
	if(len(deltaModel) == 0) {
		return void;
	}
		
	return deltaModel;
}

//
function BulletModel::Unmarshall(model){
	
	if (len(model) == 0) {
		return;
	}
	
	foreach(var field in model) {
		var key = field[0], value = field[1];
		
		switch(key) {
		case "Pid":
			this.Pid = value;
			break;
		case "position":
			this.position = value;
			break;
		case "direction":
			this.direction = value;
			break;
		case "speed":
			this.speed = value;
			break;
		case "damage":
			this.damage = value;
			break;
		case "rof":
			this.radiusOfInfluence = value;
			break; 
		}
	}
}

#endif
