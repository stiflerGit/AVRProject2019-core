#ifndef PLAYER_S3D
#define PLAYER_S3D

#include "Level.s3d"
#include "Weapon/RocketLauncher.s3d"
#include "Weapon/Railgun.s3d"
#include "Bullet.s3d"

// defaults
#define PLAYER_DEFAULT_HP 100

// physics
#define PLAYER_JUMP_HEIGHT 1.1
#define PLAYER_JUMP_LENGTH 3
#define PLAYER_VELOCITY 1.0

// graphics
#define SWAT_START_WALK 16
#define SWAT_END_WALK   48

// input events
#define PLAYER_RUN 1
#define PLAYER_LEFT 2
#define PLAYER_RIGHT 4
#define PLAYER_UP 8
#define PLAYER_DOWN 16
#define PLAYER_SHOOT 32
#define PLAYER_RELOAD 64
#define PLAYER_JUMP 128

function isEventSet(event, maskEvent) {
	var res = event & maskevent;
	if(res == 0){
		return false;
	}
	return true;
}

class player
{
	var level;
	// graphics
	var lowerObj;
	var upperObj;
	var obj;
	// sound
	var step_fx;
	// model
	var ID;
	var position;
	var angle;
	var direction;
	var hVel, vVel; /**< horizontal and vertical velocity */
	var step;
	var frame_step;
	var current_frame;
	var color;
	//
	var weapon;
	var shootedBullets;
	var nOwnedBullets;
	var reloadTimeout;
	var isInTheAir;
	var hp;
	
	Init(col);
	Draw();
	GetModel();
	SetModel(model);
	SetShootedBulletsModel(model);
	GetShootedBulletModels();
	GetShootedBulletDeltaModels(model);
	GetDeltaModel(model);
	setPosition(pos);
	setRotation(angle);
	getHeadPosition();
	getHeadDirection();
	Update(event);
	RemoveVoidBullets();
	
	reload();
	isReloading();
	getNextFrame();
	getPreviousFrame();
	is3DCollidingSegment(oldposition, position);
	is3DCollidingOnTopSegment(oldposition, position);
	postProcessPositionAndAirState(oldposition, position);
};

function Player::Player(ID, level){
	this.ID = ID;
	this.level = level;
	isInTheAir = false;
	hVel = 0.0;
	vVel = 0.0;
	reloadTimeout = 0.0;
	hp = PLAYER_DEFAULT_HP;
}

function player::GetModel() {
	
	var bulletModels = GetShootedBulletModels();
	
	return {
		{"ID", ID},
		{"position", position},
		{"angle", angle},
		{"direction", direction},
		{"hVel", hVel},
		{"vVel", vVel},
		{"current_frame", current_frame},
		{"nOwnedBullets", nOwnedBullets},
		{"reloadTimeout", reloadTimeout},
		{"isInTheAir", isInTheAir},
		{"hp", hp},
		{"shootedBullets", bulletModels}
	};
}

/**
 * Wath do you have to apply to model to a player to be equal to me??
 */
function Player::GetDeltaModel(model) {
	var myModel = this.GetModel();
	
	if (model == void || len(model) == 0) {
		return myModel;
	}
	
	if(len(model) < len(myModel)) {
		OutputLN("ERROR len(model) < len(myModel)");
	}
	
	var deltaModel = Array(0);
	for (var i=0; i<len(myModel); i++){
		var myModelKey = myModel[i][0], myModelVal = myModel[i][1];
		var modelKey = model[i][0], modelVal = model[i][1];
		
		if (myModelkey=="shootedBullets") {
//			var shootedBulletDeltaModels = GetShootedBulletDeltaModels(modelVal);
//			if (shootedBulletDeltaModels != void) {
			if (myModelVal != void) {
				aadd(deltaModel, {"shootedBullets", myModelVal});
			}
					
//			}
			continue;
		}
		
		if(modelKey != myModelKey) {
			Quit("modelKey != myModelKey");
		}
		
		if (myModelVal != modelVal) {
			aadd(deltaModel, myModel[i]);
		}
		
	}
	
	if(len(deltaModel) == 0) {
		return void;
	}
		
	return deltaModel;
}

function player::SetModel(model) {
	foreach(var field in model) {
		var key = field[0], value = field[1];
		
		switch(key) {
		case "ID":
			this.ID = value;
			break;
		case "position":
			this.position = value;
			break;
		case "angle": 
			this.angle = value;
			break;
		case "direction": 
			this.direction = value;
			break;
		case "hVel": 
			this.hVel = value;
			break;
		case "vVel":
			this.vVel = value;
			break;
		case "current_frame":
			this.current_frame = value;
			break;
		case "nOwnedBullets": 
			this.nOwnedBullets = value;
			break;
		case "reloadTimeout":
			this.reloadTimeout = value;
			break;
		case "isInTheAir": 
			this.isInTheAir = value;
			break;
		case "hp":
			this.hp = value;
			break;
		case "shootedBullets":
			setShootedBulletsModel(value);
			break;
		}
	}
	
	setPosition(this.position);
	setrotation(this.angle);
}

function player::SetShootedBulletsModel(model) {
	if(model == void || len(model) == 0) {
		return;
	}
	
	asize(shootedBullets, len(model));
	var bulletModels = model;
	for (var i=0; i < len(bulletModels); i++) {
		var bulletModel = bulletModels[i];
		
		if (bulletModel == void) {
			shootedBullets[i] = void;
			continue;
		}
		
		if (len(bulletModel) == 0) {
			continue;
		}
		
		if (shootedBullets[i] == void) {
			shootedBullets[i] = Bullet(this.ID);
			shootedBullets[i].Init([0,0,0], [0,0,0], 0, 0);
		}
		shootedBullets[i].SetModel(bulletModel);
	}
	
}

function Player::GetShootedBulletModels() {
	var bulletModels = Array(0);
	foreach (var bullet in shootedBullets) {
		if (bullet != void) {
			aadd(bulletModels, bullet.GetModel());	
		} else {
			aadd(bulletModels, void);
		}
	}
	
	if (len(bulletModels) == 0) {
		return void;
	}
	
	return bulletModels;
}


function Player::GetShootedBulletDeltaModels(model) { 
		
	if(model == void || len(model) == 0) {
		return GetShootedBulletModels();
	}
	
	var deltaModels = Array(0);
	
	for(var i=0; i<len(shootedBullets); i++) {
		var shootedBullet = shootedBullets[i];
		
		if (shootedBullet == void) {
			aadd(deltaModels, void);
			continue;
		}
		
		if (i>len(model) || model[i] == void) {
			aadd(deltaModels, shootedBullet.GetModel());
			continue;
		}
		
		var deltaModel = shootedBullet.GetDeltaModel(model[i]);
		if (deltaModel == void) {
			deltaModel = {};
		}
		
		aadd(deltaModels, deltaModel);
	}

}

function player::RemoveVoidBullets() {
	// remove deleted bullets
	for(var i=0; i<len(shootedBullets);){
		if (shootedBullets[i] == void) {
			adel(shootedBullets, i);
			continue;
		}
		i++;
	}
}

function player::getHeadPosition()
{
	var headPosition = this.position;
	headPosition[1] = headPosition.y + 1.5;
	return (headPosition);
}

function player::getHeadDirection()
{
	return this.direction;
}

function player::SetPosition(position)
{
	this.position = position;
	obj.setposition(this.position);
}

function player::SetRotation(angle)
{
	this.angle = angle;
	obj.setrotation(angle*180.0/PI, 0, 1, 0);
}


function player::Init(color) {	
	
	this.color = color;
	
	var lowerMesh =  CVmNewMesh("swat_lower.aam");
	lowerObj = CVmObj(lowerMesh);
	var scaling = lowerObj.Normalize(1);
	var upperMesh = CVmNewMesh("swat_upper.aam");
	upperObj = CVmObj(upperMesh);
	upperObj.SetScale(scaling);
	
	obj = CVmObj();
	obj.addchild(upperObj);
	obj.addchild(lowerObj);
	
	weapon = Railgun(this.ID, scaling);
	obj.addchild(weapon.obj);
	
	obj.ModulateMaterials(color);
	// sound
	step_fx  = CVmVRAWAV("step.wav");
	// model init
	angle = 0;
	direction = [0,0,1];
	step = 0.1;
	frame_step = 1.0;
	current_frame = SWAT_START_WALK;
	
	shootedBullets = Array(0);
	nOwnedBullets = 9;
	
}

function player::Update(event) {
	static var jumpGravity = 0.0, oldposition = position;
	var runMultiplicator;
		 
	if (!isInTheAir) {
		if (isEventSet(event, PLAYER_RUN)) {
			runMultiplicator = 1.5;
		} else {
			runMultiplicator = 1.0;
		}
		
		if (isEventSet(event, PLAYER_UP)) {
			hVel = PLAYER_VELOCITY * runMultiplicator;
			current_frame = getNextFrame();
		} else if (isEventSet(event, PLAYER_DOWN)) {
			hVel = -PLAYER_VELOCITY;
			current_frame = getPreviousFrame();
		} else{
			hVel = 0;
		}
		
		// angle and direction
		if (isEventSet(event, PLAYER_RIGHT | PLAYER_LEFT)){
			if (isEventSet(event, PLAYER_RIGHT)) {
				angle -= 0.02;
			}
			if (isEventSet(event, PLAYER_LEFT)) {
				angle += 0.02;
			}
			direction = [sin(angle), 0, cos(angle)];
		}
	    
	    if (isEventSet(event, PLAYER_JUMP)) {
	    	var vx;
	    	var h = runMultiplicator * PLAYER_JUMP_HEIGHT;
	    	var xh = runMultiplicator * PLAYER_JUMP_LENGTH / 2.0;
	    	if (hVel != 0) {
	    		vx = abs(hVel);
	    	} else {
	    		vx = PLAYER_VELOCITY;
	    	}
	    	jumpGravity = 2.0 * h * (vx^2) / (xh^2);
	    	vVel = 2.0 * h * vx / xh;
	    	isInTheAir = true;
	    }
	}
	
	if (!isReloading() && isEventSet(event, PLAYER_RELOAD)) {
		this.reload();
	}
		
	if (isEventSet(event, PLAYER_SHOOT)) {
		var bullet = weapon.Shoot(position, direction);
		if (bullet != void) {
			aadd(shootedBullets, bullet);
		}
	}
	
	oldposition = position;
	if (hVel != 0) {
		position += (hVel*direction*step);	
	}
    
    if (isInTheAir) {
    	position.y += (vVel*step - 0.5 * jumpGravity * (step^2));
    	vVel -= (jumpGravity*step);
    	if (position.y <= 0) {
    		position.y = 0.0;
    		vVel = 0.0;
    		jumpGravity = 0.0;
    		isInTheAir = false;
    	}
    }
    
    var ret = postProcessPositionAndAirState(oldposition, position);
    position = ret[0]; isInTheAir = ret[1];	
	
	setrotation(angle);
	setposition(position);	
	
	if (isReloading()) {
		reloadTimeout -= 0.01;
	}
	
	weapon.Update();
	
	
	foreach (var bullet in shootedBullets) {
		if (bullet!= void) {
			bullet.Update();
		}
	}
	
}

function Player::Draw()
{
	obj.draw(VR_FRAMENUMBER, current_frame);
	lowerObj.DrawBoundingBox();
	upperObj.DrawBoundingBox();
	foreach (var bullet in shootedBullets) {
		if (bullet != void) {
			bullet.Draw();
		}
	}
}

function Player::Reload() {
	if (weapon.nbullets >= weapon.magazineSize){
		return;
	}
	
	if (nOwnedBullets == 0) {
		return;
	}

	var nMissingBullets = weapon.magazineSize - weapon.nBullets;
	if (nOwnedBullets >= nMissingBullets) {
		weapon.nBullets += nMissingBullets;
		nOwnedBullets -= nMissingBullets;
	} else {
		weapon.nBullets += nOwnedBullets;
		nOwnedBullets = 0;
	}
	reloadTimeout = weapon.reloadInterval;	
}

function player::getNextFrame() {
	var cf = current_frame;
	cf += frame_step;
	if (cf > SWAT_END_WALK){
		step_fx.play();
		cf = SWAT_START_WALK;
	}
	return cf;
}

function player::getPreviousFrame() {
	var cf = current_frame;
	cf -= frame_step;
	if (cf < SWAT_START_WALK){
		step_fx.play();
		cf = SWAT_END_WALK;
	}
	return cf;
}

function player::isReloading() {
	return reloadTimeout > 0;
}

function player::is3DCollidingSegment(oldposition, position) {
	var wall = level.getWallObjAtPosition(position);
	if (wall == void) {
		return false;
	}
	
	var ContactPoint = vector(3),ContactNormal = vector(3);
	var isColl = wall.isColliding(oldposition, position, &ContactPoint, &ContactNormal);
	if (isColl && ContactPoint != oldposition) {
		return true;
	}
	return false;
}

function player::is3DCollidingOnTopSegment(oldposition, position) {
	var ContactPoint = vector(3),ContactNormal = vector(3);
	
	var wall = level.getWallObjAtPosition(position);
	if (wall == void) {
		return false;
	}

	var isColl = wall.isColliding(oldposition, position, &ContactPoint, &ContactNormal);
	
	if(isColl && ContactPoint != oldposition){
		var wallH = wall.GetScale().y;
		if (ContactNormal == [0,1,0] || ContactPoint.y == wallH) {
			return true;
		}
	}
	return false;	
}

function player::postProcessPositionAndAirState(oldposition, position) {
	
	if (oldposition == position) {
		return {position, isInTheAir};
	}
	
	if (is3DCollidingSegment(oldposition, position)) {
		if(is3DCollidingOnTopSegment(oldposition, position)) {
			var wall = level.getWallObjAtPosition(position);
			var wallHeight = wall.GetScale().y;
			position.y = wallHeight;
			return {position, false};
		}
		position.x = oldposition.x;
		position.z = oldposition.z;
	}
	
	if (is3DCollidingSegment(position, oldposition)) {
		return {position, true};
	}
	
	return {position, isInTheAir};
}

#endif
